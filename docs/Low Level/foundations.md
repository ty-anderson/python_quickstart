
# ğŸ”¹ Foundations

* **Binary & Hexadecimal** â†’ how computers represent data.
* **Boolean logic & gates** â†’ the â€œmathâ€ of 0s and 1s.
* **Memory addressing** â†’ how data lives in RAM and how the CPU finds it.

---

### ğŸ”¹ CPU & Instructions

* **Assembly language** â†’ the CPUâ€™s direct instructions (add, move, jump).
* **Instruction set architectures (ISA)** â†’ x86 vs ARM vs RISC-V.
* **Registers & stack** â†’ tiny but super-fast memory inside the CPU.
* **Interrupts** â†’ how hardware says â€œhey CPU, stop and listen to me.â€

---

### ğŸ”¹ Operating System Concepts

* **System calls** â†’ how user programs ask the OS to do privileged work (like file access).
* **Processes & threads** â†’ how the OS runs multiple programs â€œat once.â€
* **Virtual memory** â†’ how programs see their own memory space, even though RAM is shared.
* **Scheduling** â†’ how the OS decides which process runs next.
* **Device drivers** â†’ how the OS talks to hardware.

---

### ğŸ”¹ Hardware & I/O

* **Buses & ports** â†’ how components (CPU, RAM, GPU, disk) communicate.
* **Storage devices** â†’ how disks store and retrieve data.
* **Networking** â†’ packets, NICs, how TCP/IP actually leaves your computer.
* **Keyboard/mouse (HID), display, GPU basics** â†’ common hardware roles.

---

### ğŸ”¹ Systems Programming

* **Memory management** â†’ stack vs heap, allocation, fragmentation.
* **Pointers & references** â†’ how languages like C and Rust directly manipulate memory.
* **Concurrency** â†’ threads, locks, atomics, deadlocks.
* **File systems** â†’ how bytes on disk become folders/files.
* **Compilers & interpreters** â†’ how code becomes machine instructions.

---

### ğŸ”¹ Cool Projects to Learn By Doing

* Write a tiny program in **assembly**.
* Implement a **toy memory allocator** in C or Rust.
* Build a very simple **command-line shell**.
* Follow an OS tutorial (like â€œwrite your own kernel in Rustâ€ â†’ [Phil Oppâ€™s blog](https://os.phil-opp.com/)).
* Write a basic **network packet sniffer**.
